// YouTubeå­—å¹•å–å¾—ã®æ‹¡å¼µç‰ˆï¼ˆè‡ªå‹•ç”Ÿæˆå­—å¹•å¯¾å¿œï¼‰

export interface CaptionTrack {
  language: string;
  name: string;
  isAutoGenerated: boolean;
  baseUrl: string;
}

// å‹•ç”»ã®å­—å¹•ãƒˆãƒ©ãƒƒã‚¯æƒ…å ±ã‚’å–å¾—ï¼ˆæ”¹å–„ç‰ˆï¼‰
export async function getAvailableCaptionTracks(_videoId: string): Promise<CaptionTrack[]> {
  try {
    let playerResponse = null;
    
    // æ–¹æ³•1: window.ytInitialPlayerResponse ã‚’ç›´æ¥å–å¾—
    if ((window as any).ytInitialPlayerResponse) {
      playerResponse = (window as any).ytInitialPlayerResponse;
      console.log('Found ytInitialPlayerResponse in window');
    }
    
    // æ–¹æ³•2: ytcfgã‹ã‚‰ã®å–å¾—ã‚’è©¦ã¿ã‚‹
    if (!playerResponse && (window as any).ytcfg) {
      const ytcfg = (window as any).ytcfg;
      if (ytcfg.data_ && ytcfg.data_.PLAYER_VARS && ytcfg.data_.PLAYER_VARS.embedded_player_response) {
        try {
          playerResponse = JSON.parse(ytcfg.data_.PLAYER_VARS.embedded_player_response);
          console.log('Found playerResponse in ytcfg');
        } catch (e) {
          console.warn('Failed to parse embedded_player_response');
        }
      }
    }
    
    // æ–¹æ³•3: ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚¿ã‚°ã‹ã‚‰å–å¾—
    if (!playerResponse) {
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        const content = script.textContent || '';
        
        // ã‚ˆã‚ŠåŒ…æ‹¬çš„ãªãƒ‘ã‚¿ãƒ¼ãƒ³ãƒãƒƒãƒãƒ³ã‚°
        const patterns = [
          /ytInitialPlayerResponse\s*=\s*({.+?})\s*;/,
          /window\["ytInitialPlayerResponse"\]\s*=\s*({.+?})\s*;/,
          /ytInitialPlayerResponse\s*=\s*({[\s\S]+?})\s*;\s*(?:var|let|const|$)/,
          /"playerResponse"\s*:\s*"({[^"]+})"/
        ];
        
        for (const pattern of patterns) {
          const match = content.match(pattern);
          if (match) {
            try {
              // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã•ã‚ŒãŸJSONã®å ´åˆ
              let jsonStr = match[1];
              if (jsonStr.includes('\\')) {
                jsonStr = jsonStr.replace(/\\"/g, '"').replace(/\\\\/g, '\\');
              }
              playerResponse = JSON.parse(jsonStr);
              console.log('Found ytInitialPlayerResponse in script');
              break;
            } catch (e) {
              console.warn('Failed to parse ytInitialPlayerResponse from script');
            }
          }
        }
        if (playerResponse) break;
      }
    }
    
    if (!playerResponse) {
      console.log('ytInitialPlayerResponse not found, waiting and retrying...');
      return [];
    }

    const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];
    console.log('Found caption tracks:', captionTracks.length);
    
    if (captionTracks.length > 0) {
      console.log('First caption track:', captionTracks[0]);
    }
    
    return captionTracks.map((track: any) => ({
      language: track.languageCode,
      name: track.name?.simpleText || track.name?.runs?.[0]?.text || '',
      isAutoGenerated: track.kind === 'asr', // asr = automatic speech recognition
      baseUrl: track.baseUrl
    }));
  } catch (error) {
    console.error('Error getting caption tracks:', error);
    return [];
  }
}

// å­—å¹•ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
export async function fetchCaptionData(trackUrl: string): Promise<string> {
  try {
    // JSONå½¢å¼ã§å–å¾—ã™ã‚‹ãŸã‚ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¿½åŠ 
    const url = new URL(trackUrl);
    
    // æ—¢å­˜ã®fmtãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¦ã€æ–°ã—ã„ã‚‚ã®ã‚’è¨­å®š
    url.searchParams.delete('fmt');
    url.searchParams.set('fmt', 'json3');
    
    // è¿½åŠ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆYouTubeãŒå¿…è¦ã¨ã™ã‚‹å ´åˆãŒã‚ã‚‹ï¼‰
    if (!url.searchParams.has('xorb')) {
      url.searchParams.set('xorb', '2');
    }
    if (!url.searchParams.has('xoaf')) {
      url.searchParams.set('xoaf', '1');
    }
    
    console.log('Fetching captions from:', url.toString());
    
    // CORSã‚’å›é¿ã™ã‚‹ãŸã‚ã«ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§å–å¾—
    const response = await new Promise<string>((resolve, reject) => {
      // Chromeæ‹¡å¼µæ©Ÿèƒ½ã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆãŒæœ‰åŠ¹ã‹ãƒã‚§ãƒƒã‚¯
      if (!chrome.runtime?.id) {
        reject(new Error('Extension context invalidated'));
        return;
      }
      
      chrome.runtime.sendMessage(
        { type: 'FETCH_CAPTIONS', url: url.toString() },
        (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
            return;
          }
          if (response?.error) {
            reject(new Error(response.error));
          } else {
            resolve(response?.data || '');
          }
        }
      );
    });
    
    console.log('Caption response length:', response.length, 'First 100 chars:', response.substring(0, 100));
    return response;
  } catch (error) {
    console.error('Error fetching caption data:', error);
    throw error;
  }
}

// JSONå­—å¹•ã‚’ãƒ‘ãƒ¼ã‚¹
export function parseCaptionJSON(jsonData: string): Caption[] {
  try {
    // ç©ºã®ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚’ãƒã‚§ãƒƒã‚¯
    if (!jsonData || jsonData.trim() === '') {
      console.warn('Empty caption data received');
      return [];
    }
    
    // ã¾ãšHTMLã‹ã©ã†ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆYouTubeãŒHTMLã‚’è¿”ã™ã“ã¨ãŒã‚ã‚‹ï¼‰
    if (jsonData.trim().startsWith('<') || jsonData.includes('<!DOCTYPE')) {
      console.error('Received HTML instead of JSON. Data preview:', jsonData.substring(0, 200));
      return [];
    }
    
    // JSONãƒ‘ãƒ¼ã‚¹ã‚’è©¦ã¿ã‚‹
    let data;
    try {
      data = JSON.parse(jsonData);
    } catch (parseError) {
      console.error('JSON parse failed. Data length:', jsonData.length);
      console.error('First 500 chars:', jsonData.substring(0, 500));
      console.error('Last 100 chars:', jsonData.substring(jsonData.length - 100));
      return [];
    }
    
    console.log('Parsed caption data structure:', Object.keys(data));
    
    // wireMagicãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆYouTubeãŒä½¿ç”¨ï¼‰
    if (data.wireMagic) {
      console.log('Found wireMagic format');
      return parseWireMagicFormat(data);
    }
    
    // æ–°ã—ã„YouTubeãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚’ãƒã‚§ãƒƒã‚¯
    if (data.actions) {
      console.log('Found actions format');
      return parseActionsFormat(data);
    }
    
    const events = data.events || [];
    console.log('Found events:', events.length);
    
    return events
      .filter((event: any) => event.segs) // ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚‹ã‚¤ãƒ™ãƒ³ãƒˆã®ã¿
      .map((event: any) => {
        const text = event.segs
          .map((seg: any) => seg.utf8)
          .join('')
          .replace(/\n/g, ' ')
          .trim();
          
        return {
          text,
          start: (event.tStartMs || 0) / 1000, // ãƒŸãƒªç§’ã‹ã‚‰ç§’ã«å¤‰æ›
          duration: (event.dDurationMs || 3000) / 1000
        };
      })
      .filter((caption: Caption) => caption.text.length > 0);
  } catch (error) {
    console.error('Error parsing caption JSON:', error, 'Data:', jsonData?.substring(0, 100));
    return [];
  }
}

// actionsãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒ‘ãƒ¼ã‚¹ï¼ˆæ–°ã—ã„YouTubeãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆï¼‰
function parseActionsFormat(data: any): Caption[] {
  try {
    const actions = data.actions || [];
    const captions: Caption[] = [];
    
    for (const action of actions) {
      if (action.updateEngagementPanelAction?.content?.transcriptRenderer?.body?.transcriptBodyRenderer?.cueGroups) {
        const cueGroups = action.updateEngagementPanelAction.content.transcriptRenderer.body.transcriptBodyRenderer.cueGroups;
        for (const group of cueGroups) {
          const cue = group.transcriptCueGroupRenderer?.cues?.[0]?.transcriptCueRenderer;
          if (cue) {
            captions.push({
              text: cue.cue?.simpleText || '',
              start: parseInt(cue.startOffsetMs || '0') / 1000,
              duration: parseInt(cue.durationMs || '3000') / 1000
            });
          }
        }
      }
    }
    
    return captions;
  } catch (error) {
    console.error('Error parsing actions format:', error);
    return [];
  }
}

// wireMagicãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®ãƒ‘ãƒ¼ã‚¹
function parseWireMagicFormat(_data: any): Caption[] {
  try {
    const captions: Caption[] = [];
    // wireMagicãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã®è§£æãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…
    // ã“ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯è¤‡é›‘ãªã®ã§ã€åŸºæœ¬çš„ãªæ§‹é€ ã®ã¿
    console.warn('wireMagic format parsing not fully implemented');
    return captions;
  } catch (error) {
    console.error('Error parsing wireMagic format:', error);
    return [];
  }
}

// ã‚¹ãƒãƒ¼ãƒˆå­—å¹•å–å¾—ï¼ˆå­—å¹•APIã‚’ä½¿ç”¨ï¼‰
export async function getSmartCaptions(videoId: string): Promise<Caption[]> {
  console.log('Getting captions for video:', videoId);
  
  try {
    // å­—å¹•ãƒˆãƒ©ãƒƒã‚¯æƒ…å ±ã‚’å–å¾—
    const tracks = await getAvailableCaptionTracks(videoId);
    console.log('Available tracks:', tracks);
    
    if (tracks.length === 0) {
      console.log('No caption tracks available');
      return [];
    }
    
    // æ—¥æœ¬èªå­—å¹•ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°è‡ªå‹•ç”Ÿæˆã€ãã‚Œã‚‚ãªã‘ã‚Œã°æœ€åˆã®ãƒˆãƒ©ãƒƒã‚¯
    let selectedTrack = tracks.find(t => t.language === 'ja' && !t.isAutoGenerated) ||
                        tracks.find(t => t.language === 'ja') ||
                        tracks[0];
    
    console.log('Selected track:', selectedTrack);
    
    // å­—å¹•ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
    const captionData = await fetchCaptionData(selectedTrack.baseUrl);
    const captions = parseCaptionJSON(captionData);
    
    console.log(`Loaded ${captions.length} captions`);
    return captions;
  } catch (error) {
    console.error('Error in getSmartCaptions:', error);
    return [];
  }
}

// ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
export interface Caption {
  text: string;
  start: number;
  duration: number;
}

// DOMç›£è¦–ã«ã‚ˆã‚‹å­—å¹•å–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ãƒ»æ”¹å–„ç‰ˆï¼‰
export function observeCaptionsFromDOM(callback: (captions: Caption[]) => void): () => void {
  console.log('Starting DOM-based caption observation');
  
  // å­—å¹•ã‚’æœ‰åŠ¹ã«ã™ã‚‹ï¼ˆè¤‡æ•°å›è©¦è¡Œï¼‰
  let enableAttempts = 0;
  const enableCaptionsWithRetry = () => {
    enableCaptions();
    enableAttempts++;
    
    // 3ç§’å¾Œã«å†åº¦æœ‰åŠ¹åŒ–ã‚’è©¦ã¿ã‚‹ï¼ˆæœ€å¤§3å›ï¼‰
    if (enableAttempts < 3) {
      setTimeout(() => {
        const captionBtn = document.querySelector('.ytp-subtitles-button[aria-pressed="false"]');
        if (captionBtn) {
          console.log(`Retrying caption enable (attempt ${enableAttempts + 1})`);
          enableCaptionsWithRetry();
        }
      }, 3000);
    }
  };
  
  enableCaptionsWithRetry();
  
  // å­—å¹•ç®¡ç†ç”¨ã®çŠ¶æ…‹
  const captionMap = new Map<string, Caption>(); // ã‚­ãƒ¼: é–‹å§‹æ™‚åˆ»ã€å€¤: å­—å¹•
  const completedTexts = new Map<string, number>(); // å®Œäº†æ¸ˆã¿ãƒ†ã‚­ã‚¹ãƒˆã¨å®Œäº†æ™‚åˆ»
  let observationCount = 0; // è¦³æ¸¬å›æ•°
  
  // ãƒ‡ãƒãƒƒã‚°ç”¨: å‡¦ç†çŠ¶æ³ã‚’è¿½è·¡
  const debugState = {
    lastProcessedTexts: new Set<string>(),
    duplicateCount: 0,
    totalObservations: 0
  };
  
  const captionObserver = new MutationObserver(() => {
    debugState.totalObservations++;
    observationCount++;
    
    const captionElements = document.querySelectorAll('.ytp-caption-segment');
    if (captionElements.length === 0) return;
    
    const videoElement = document.querySelector('video');
    if (!videoElement) return;
    
    const currentTime = videoElement.currentTime;
    
    // ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ã‚‹ãƒ†ã‚­ã‚¹ãƒˆã‚’åé›†ï¼ˆé‡è¤‡æ’é™¤ï¼‰
    const currentTexts = new Set<string>();
    const textsByTime = new Map<string, string[]>(); // æ™‚åˆ»ã”ã¨ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    
    captionElements.forEach((element) => {
      let text = element.textContent || '';
      
      // ãƒ‡ãƒãƒƒã‚°: å…ƒã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è¨˜éŒ²
      const originalText = text;
      
      // YouTube UIã®è¦ç´ ã‚’é™¤å»
      const uiPatterns = [
        /è‹±èª\(è‡ªå‹•ç”Ÿæˆ\)>>/g,  // ã€Œè‹±èª(è‡ªå‹•ç”Ÿæˆ)>>ã€ã‚’é™¤å»
        /è‹±èª\(è‡ªå‹•ç”Ÿæˆ\)>>æ—¥æœ¬èªã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨­å®š/g,
        />>.*ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨­å®š/g,
        /ã‚’ã‚¯ãƒªãƒƒã‚¯ã—ã¦è¨­å®š/g,
        /\[.*\]/g,
        /\(.*\)$/g,
        /è‹±èª$/g,
        /æ—¥æœ¬èª$/g,
        /^>>/g  // å…ˆé ­ã® >> ã‚’å‰Šé™¤
      ];
      
      for (const pattern of uiPatterns) {
        const before = text;
        text = text.replace(pattern, '').trim();
        if (before !== text) {
          console.log(`ğŸ§™ Pattern ${pattern} removed: "${before}" â†’ "${text}"`);
        }
      }
      
      // ç‰¹åˆ¥ãªã‚±ãƒ¼ã‚¹: ã€Œè‹±èª(è‡ªå‹•ç”Ÿæˆ)>>ã€ã®ã¿ã®å ´åˆã¯å®Œå…¨ã«ç„¡è¦–
      if (originalText === 'è‹±èª(è‡ªå‹•ç”Ÿæˆ)>>' || originalText === 'è‹±èªï¼ˆè‡ªå‹•ç”Ÿæˆï¼‰>>' || 
          originalText.match(/^è‹±èª[(ï¼ˆ]è‡ªå‹•ç”Ÿæˆ[)ï¼‰]>>$/)) {
        return; // ã“ã®è¦ç´ ã‚’ã‚¹ã‚­ãƒƒãƒ—
      }
      
      if (text && text.length > 1) {
        currentTexts.add(text);
        
        // æ™‚åˆ»ã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–ï¼ˆ0.5ç§’ã®ç²¾åº¦ï¼‰
        const timeKey = (Math.round(currentTime * 2) / 2).toFixed(1);
        if (!textsByTime.has(timeKey)) {
          textsByTime.set(timeKey, []);
        }
        const timeTexts = textsByTime.get(timeKey)!;
        if (!timeTexts.includes(text)) {
          timeTexts.push(text);
        }
      }
    });
    
    // å„æ™‚åˆ»ã‚°ãƒ«ãƒ¼ãƒ—ã‹ã‚‰æœ€ã‚‚é•·ã„ãƒ†ã‚­ã‚¹ãƒˆã®ã¿ã‚’æ¡ç”¨
    const uniqueTexts: string[] = [];
    const timeKeysArray = Array.from(textsByTime.keys()).sort();
    
    for (const timeKey of timeKeysArray) {
      const texts = textsByTime.get(timeKey)!;
      if (texts.length > 1) {
        // åŒã˜æ™‚åˆ»ã«è¤‡æ•°ã®ãƒ†ã‚­ã‚¹ãƒˆãŒã‚ã‚‹å ´åˆ
        // 1. éƒ¨åˆ†ãƒ†ã‚­ã‚¹ãƒˆã‚’é™¤å¤–
        const filteredTexts = texts.filter(text => {
          // ä»–ã®ãƒ†ã‚­ã‚¹ãƒˆã«å®Œå…¨ã«å«ã¾ã‚Œã¦ã„ã‚‹å ´åˆã¯é™¤å¤–
          return !texts.some(other => other !== text && other.includes(text));
        });
        
        // 2. æœ€ã‚‚é•·ã„ã‚‚ã®ã‚’é¸æŠ
        const selectedText = filteredTexts.length > 0 
          ? filteredTexts.reduce((a, b) => a.length > b.length ? a : b)
          : texts[0];
          
        uniqueTexts.push(selectedText);
        if (texts.length > 1) {
          console.log(`â±ï¸ Time ${timeKey}: ${texts.length} texts â†’ selected: "${selectedText.substring(0, 30)}..."`);
        }
      } else {
        uniqueTexts.push(texts[0]);
      }
    }
    
    // ãƒ‡ãƒãƒƒã‚°: åŒã˜ãƒ†ã‚­ã‚¹ãƒˆãŒè¤‡æ•°å›å‡ºç¾ã—ã¦ã„ã‚‹å ´åˆ
    if (captionElements.length > uniqueTexts.length) {
      console.log(`âš ï¸ Duplicate elements detected: ${captionElements.length} elements â†’ ${uniqueTexts.length} unique texts`);
      debugState.duplicateCount++;
    }
    
    // å„ãƒ†ã‚­ã‚¹ãƒˆã‚’å‡¦ç†
    uniqueTexts.forEach((text) => {
      // æ—¢ã«å®Œäº†æ¸ˆã¿ã®ãƒ†ã‚­ã‚¹ãƒˆã‹ãƒã‚§ãƒƒã‚¯ï¼ˆæœ€è¿‘ã®ã‚‚ã®ã¯é™¤å¤–ï¼‰
      const completedTime = completedTexts.get(text);
      if (completedTime !== undefined && currentTime - completedTime < 5) {
        // 5ç§’ä»¥å†…ã«åŒã˜ãƒ†ã‚­ã‚¹ãƒˆã¯ç„¡è¦–
        return;
      }
      
      // éƒ¨åˆ†çš„ãªãƒ†ã‚­ã‚¹ãƒˆãŒæ—¢ã«å­˜åœ¨ã™ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      for (const [_, caption] of captionMap.entries()) {
        // ã“ã®ãƒ†ã‚­ã‚¹ãƒˆãŒæ—¢å­˜ã®å­—å¹•ã«å«ã¾ã‚Œã¦ã„ã‚‹ï¼ˆéƒ¨åˆ†çš„ï¼‰
        if (caption.text.includes(text) && caption.text !== text && 
            Math.abs(caption.start - currentTime) < 2) {
          console.log(`â­ï¸ Skipping partial text: "${text}" (already in "${caption.text.substring(0, 30)}...")`);
          return;
        }
      }
      
      // å­—å¹•ã¨ã—ã¦è¨˜éŒ²
      const captionKey = `${currentTime.toFixed(1)}-${text.substring(0, 20)}`;
      
      // æ—¢å­˜ã®å­—å¹•ã‚’æ¢ã™ï¼ˆæ™‚é–“ãŒè¿‘ã„ã‚‚ã®ï¼‰
      let existingCaption: Caption | null = null;
      let existingKey: string | null = null;
      
      for (const [key, caption] of captionMap.entries()) {
        // åŒã˜ãƒ†ã‚­ã‚¹ãƒˆã§ã€æ™‚é–“ãŒè¿‘ã„ï¼ˆå‰å¾Œ5ç§’ä»¥å†…ï¼‰
        if (caption.text === text && Math.abs(caption.start - currentTime) < 5) {
          existingCaption = caption;
          existingKey = key;
          break;
        }
        
        // ãƒ†ã‚­ã‚¹ãƒˆãŒå‰ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å«ã‚€ï¼ˆå¢—åˆ†æ›´æ–°ï¼‰
        if (text.startsWith(caption.text) && text.length > caption.text.length &&
            Math.abs(caption.start - currentTime) < 3) {
          existingCaption = caption;
          existingKey = key;
          break;
        }
      }
      
      if (existingCaption && existingKey) {
        // æ—¢å­˜ã®å­—å¹•ã‚’æ›´æ–°
        existingCaption.text = text;
        existingCaption.duration = Math.max(existingCaption.duration, currentTime - existingCaption.start + 1);
      } else {
        // æ–°ã—ã„å­—å¹•ã¨ã—ã¦è¿½åŠ 
        captionMap.set(captionKey, {
          text: text,
          start: currentTime,
          duration: 2 // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ2ç§’
        });
        console.log(`ğŸ“ New caption at ${currentTime.toFixed(1)}s: "${text.substring(0, 40)}..."`);
      }
    });
    
    // ç”»é¢ã‹ã‚‰æ¶ˆãˆãŸãƒ†ã‚­ã‚¹ãƒˆã‚’å®Œäº†æ¸ˆã¿ã¨ã—ã¦ãƒãƒ¼ã‚¯
    for (const [_key, caption] of captionMap.entries()) {
      // ç¾åœ¨è¡¨ç¤ºã•ã‚Œã¦ã„ãªã„ãƒ†ã‚­ã‚¹ãƒˆ
      if (!currentTexts.has(caption.text)) {
        // ã¾ã å®Œäº†æ¸ˆã¿ã§ãªã„å ´åˆ
        if (!completedTexts.has(caption.text)) {
          completedTexts.set(caption.text, caption.start + caption.duration);
          console.log(`âœ… Caption completed: "${caption.text.substring(0, 40)}..."`);
        }
      }
    }
    
    // å¤ã„å®Œäº†æ¸ˆã¿ãƒ†ã‚­ã‚¹ãƒˆã‚’å‰Šé™¤ï¼ˆãƒ¡ãƒ¢ãƒªç¯€ç´„ï¼‰
    for (const [text, time] of completedTexts.entries()) {
      if (currentTime - time > 30) { // 30ç§’ä»¥ä¸Šå‰ã®ã‚‚ã®ã¯å‰Šé™¤
        completedTexts.delete(text);
      }
    }
    
    // å¤ã„å­—å¹•ã‚’å‰Šé™¤ï¼ˆ5åˆ†ä»¥ä¸Šå‰ã®ã‚‚ã®ã ã‘å‰Šé™¤ï¼‰
    for (const [key, caption] of captionMap.entries()) {
      if (caption.start + caption.duration < currentTime - 300) {
        captionMap.delete(key);
      }
    }
    
    // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å®šæœŸçš„ã«å‡ºåŠ›
    if (observationCount % 50 === 0) {
      console.log(`ğŸ“Š Caption stats: ${captionMap.size} captions, ${completedTexts.size} completed, ${debugState.duplicateCount} duplicate detections`);
    }
    
    // ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
    const allCaptions = Array.from(captionMap.values())
      .sort((a, b) => a.start - b.start);
    callback(allCaptions);
  });
  
  // å­—å¹•ã‚³ãƒ³ãƒ†ãƒŠã‚’ç›£è¦–
  const setupObserver = () => {
    const captionContainer = document.querySelector('.ytp-caption-window-container');
    if (captionContainer) {
      captionObserver.observe(captionContainer, {
        childList: true,
        subtree: true,
        characterData: true
      });
      console.log('Started observing caption container');
      return true;
    }
    return false;
  };
  
  if (!setupObserver()) {
    console.log('Caption container not found, will retry...');
    // ãƒªãƒˆãƒ©ã‚¤
    const retryInterval = setInterval(() => {
      if (setupObserver()) {
        clearInterval(retryInterval);
      }
    }, 1000);
    
    // 10ç§’å¾Œã«ãƒªãƒˆãƒ©ã‚¤ã‚’åœæ­¢
    setTimeout(() => clearInterval(retryInterval), 10000);
  }
  
  // ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–¢æ•°ã‚’è¿”ã™
  return () => {
    captionObserver.disconnect();
    console.log('Stopped observing captions');
    console.log(`Final stats: ${debugState.totalObservations} observations, ${debugState.duplicateCount} duplicate detections`);
  };
}

// YouTubeå­—å¹•ã‚’æœ‰åŠ¹ã«ã™ã‚‹
function enableCaptions() {
  try {
    // æ–¹æ³•1: å­—å¹•ãƒœã‚¿ãƒ³ã‚’ã‚¯ãƒªãƒƒã‚¯
    const subtitleButton = document.querySelector('.ytp-subtitles-button') as HTMLButtonElement;
    if (subtitleButton) {
      // aria-pressedå±æ€§ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦å­—å¹•ãŒã‚ªãƒ•ã®å ´åˆã¯ã‚¯ãƒªãƒƒã‚¯
      if (subtitleButton.getAttribute('aria-pressed') === 'false') {
        console.log('Clicking subtitle button to enable captions');
        subtitleButton.click();
        
        // ã‚¯ãƒªãƒƒã‚¯å¾Œã«çŠ¶æ…‹ã‚’ç¢ºèª
        setTimeout(() => {
          const pressed = subtitleButton.getAttribute('aria-pressed');
          console.log('Subtitle button state after click:', pressed);
        }, 500);
      } else {
        console.log('Captions already enabled');
      }
    } else {
      console.log('Subtitle button not found');
    }
    
    // æ–¹æ³•2: YouTube Player APIã‚’ä½¿ã†
    const player = document.querySelector('#movie_player') as any;
    if (player && player.getOption) {
      try {
        // åˆ©ç”¨å¯èƒ½ãªå­—å¹•ãƒˆãƒ©ãƒƒã‚¯ã‚’å–å¾—
        const tracks = player.getOption('captions', 'tracklist');
        if (tracks && tracks.length > 0) {
          console.log('Available caption tracks:', tracks.length);
          // æ—¥æœ¬èªå­—å¹•ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°æœ€åˆã®ãƒˆãƒ©ãƒƒã‚¯
          const jpTrack = tracks.find((t: any) => t.languageCode === 'ja') || tracks[0];
          player.setOption('captions', 'track', jpTrack);
          console.log('Enabled captions via Player API');
        }
      } catch (e) {
        console.log('Player API method failed:', e);
      }
    }
  } catch (error) {
    console.error('Error enabling captions:', error);
  }
}