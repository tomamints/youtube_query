// YouTube字幕取得の拡張版（自動生成字幕対応）

export interface CaptionTrack {
  language: string;
  name: string;
  isAutoGenerated: boolean;
  baseUrl: string;
}

// 動画の字幕トラック情報を取得（改善版）
export async function getAvailableCaptionTracks(_videoId: string): Promise<CaptionTrack[]> {
  try {
    let playerResponse = null;
    
    // 方法1: window.ytInitialPlayerResponse を直接取得
    if ((window as any).ytInitialPlayerResponse) {
      playerResponse = (window as any).ytInitialPlayerResponse;
      console.log('Found ytInitialPlayerResponse in window');
    }
    
    // 方法2: ytcfgからの取得を試みる
    if (!playerResponse && (window as any).ytcfg) {
      const ytcfg = (window as any).ytcfg;
      if (ytcfg.data_ && ytcfg.data_.PLAYER_VARS && ytcfg.data_.PLAYER_VARS.embedded_player_response) {
        try {
          playerResponse = JSON.parse(ytcfg.data_.PLAYER_VARS.embedded_player_response);
          console.log('Found playerResponse in ytcfg');
        } catch (e) {
          console.warn('Failed to parse embedded_player_response');
        }
      }
    }
    
    // 方法3: スクリプトタグから取得
    if (!playerResponse) {
      const scripts = document.querySelectorAll('script');
      for (const script of scripts) {
        const content = script.textContent || '';
        
        // より包括的なパターンマッチング
        const patterns = [
          /ytInitialPlayerResponse\s*=\s*({.+?})\s*;/,
          /window\["ytInitialPlayerResponse"\]\s*=\s*({.+?})\s*;/,
          /ytInitialPlayerResponse\s*=\s*({[\s\S]+?})\s*;\s*(?:var|let|const|$)/,
          /"playerResponse"\s*:\s*"({[^"]+})"/
        ];
        
        for (const pattern of patterns) {
          const match = content.match(pattern);
          if (match) {
            try {
              // エスケープされたJSONの場合
              let jsonStr = match[1];
              if (jsonStr.includes('\\')) {
                jsonStr = jsonStr.replace(/\\"/g, '"').replace(/\\\\/g, '\\');
              }
              playerResponse = JSON.parse(jsonStr);
              console.log('Found ytInitialPlayerResponse in script');
              break;
            } catch (e) {
              console.warn('Failed to parse ytInitialPlayerResponse from script');
            }
          }
        }
        if (playerResponse) break;
      }
    }
    
    if (!playerResponse) {
      console.log('ytInitialPlayerResponse not found, waiting and retrying...');
      return [];
    }

    const captionTracks = playerResponse?.captions?.playerCaptionsTracklistRenderer?.captionTracks || [];
    console.log('Found caption tracks:', captionTracks.length);
    
    if (captionTracks.length > 0) {
      console.log('First caption track:', captionTracks[0]);
    }
    
    return captionTracks.map((track: any) => ({
      language: track.languageCode,
      name: track.name?.simpleText || track.name?.runs?.[0]?.text || '',
      isAutoGenerated: track.kind === 'asr', // asr = automatic speech recognition
      baseUrl: track.baseUrl
    }));
  } catch (error) {
    console.error('Error getting caption tracks:', error);
    return [];
  }
}

// 字幕データを取得
export async function fetchCaptionData(trackUrl: string): Promise<string> {
  try {
    // JSON形式で取得するためのパラメータを追加
    const url = new URL(trackUrl);
    
    // 既存のfmtパラメータを削除して、新しいものを設定
    url.searchParams.delete('fmt');
    url.searchParams.set('fmt', 'json3');
    
    // 追加のパラメータ（YouTubeが必要とする場合がある）
    if (!url.searchParams.has('xorb')) {
      url.searchParams.set('xorb', '2');
    }
    if (!url.searchParams.has('xoaf')) {
      url.searchParams.set('xoaf', '1');
    }
    
    console.log('Fetching captions from:', url.toString());
    
    // CORSを回避するためにバックグラウンドで取得
    const response = await new Promise<string>((resolve, reject) => {
      // Chrome拡張機能のコンテキストが有効かチェック
      if (!chrome.runtime?.id) {
        reject(new Error('Extension context invalidated'));
        return;
      }
      
      chrome.runtime.sendMessage(
        { type: 'FETCH_CAPTIONS', url: url.toString() },
        (response) => {
          if (chrome.runtime.lastError) {
            reject(new Error(chrome.runtime.lastError.message));
            return;
          }
          if (response?.error) {
            reject(new Error(response.error));
          } else {
            resolve(response?.data || '');
          }
        }
      );
    });
    
    console.log('Caption response length:', response.length, 'First 100 chars:', response.substring(0, 100));
    return response;
  } catch (error) {
    console.error('Error fetching caption data:', error);
    throw error;
  }
}

// JSON字幕をパース
export function parseCaptionJSON(jsonData: string): Caption[] {
  try {
    // 空のレスポンスをチェック
    if (!jsonData || jsonData.trim() === '') {
      console.warn('Empty caption data received');
      return [];
    }
    
    // まずHTMLかどうかチェック（YouTubeがHTMLを返すことがある）
    if (jsonData.trim().startsWith('<') || jsonData.includes('<!DOCTYPE')) {
      console.error('Received HTML instead of JSON. Data preview:', jsonData.substring(0, 200));
      return [];
    }
    
    // JSONパースを試みる
    let data;
    try {
      data = JSON.parse(jsonData);
    } catch (parseError) {
      console.error('JSON parse failed. Data length:', jsonData.length);
      console.error('First 500 chars:', jsonData.substring(0, 500));
      console.error('Last 100 chars:', jsonData.substring(jsonData.length - 100));
      return [];
    }
    
    console.log('Parsed caption data structure:', Object.keys(data));
    
    // wireMagicフォーマットをチェック（YouTubeが使用）
    if (data.wireMagic) {
      console.log('Found wireMagic format');
      return parseWireMagicFormat(data);
    }
    
    // 新しいYouTubeフォーマットをチェック
    if (data.actions) {
      console.log('Found actions format');
      return parseActionsFormat(data);
    }
    
    const events = data.events || [];
    console.log('Found events:', events.length);
    
    return events
      .filter((event: any) => event.segs) // テキストがあるイベントのみ
      .map((event: any) => {
        const text = event.segs
          .map((seg: any) => seg.utf8)
          .join('')
          .replace(/\n/g, ' ')
          .trim();
          
        return {
          text,
          start: (event.tStartMs || 0) / 1000, // ミリ秒から秒に変換
          duration: (event.dDurationMs || 3000) / 1000
        };
      })
      .filter((caption: Caption) => caption.text.length > 0);
  } catch (error) {
    console.error('Error parsing caption JSON:', error, 'Data:', jsonData?.substring(0, 100));
    return [];
  }
}

// actionsフォーマットのパース（新しいYouTubeフォーマット）
function parseActionsFormat(data: any): Caption[] {
  try {
    const actions = data.actions || [];
    const captions: Caption[] = [];
    
    for (const action of actions) {
      if (action.updateEngagementPanelAction?.content?.transcriptRenderer?.body?.transcriptBodyRenderer?.cueGroups) {
        const cueGroups = action.updateEngagementPanelAction.content.transcriptRenderer.body.transcriptBodyRenderer.cueGroups;
        for (const group of cueGroups) {
          const cue = group.transcriptCueGroupRenderer?.cues?.[0]?.transcriptCueRenderer;
          if (cue) {
            captions.push({
              text: cue.cue?.simpleText || '',
              start: parseInt(cue.startOffsetMs || '0') / 1000,
              duration: parseInt(cue.durationMs || '3000') / 1000
            });
          }
        }
      }
    }
    
    return captions;
  } catch (error) {
    console.error('Error parsing actions format:', error);
    return [];
  }
}

// wireMagicフォーマットのパース
function parseWireMagicFormat(_data: any): Caption[] {
  try {
    const captions: Caption[] = [];
    // wireMagicフォーマットの解析ロジックを実装
    // このフォーマットは複雑なので、基本的な構造のみ
    console.warn('wireMagic format parsing not fully implemented');
    return captions;
  } catch (error) {
    console.error('Error parsing wireMagic format:', error);
    return [];
  }
}

// スマート字幕取得（字幕APIを使用）
export async function getSmartCaptions(videoId: string): Promise<Caption[]> {
  console.log('Getting captions for video:', videoId);
  
  try {
    // 字幕トラック情報を取得
    const tracks = await getAvailableCaptionTracks(videoId);
    console.log('Available tracks:', tracks);
    
    if (tracks.length === 0) {
      console.log('No caption tracks available');
      return [];
    }
    
    // 日本語字幕を優先、なければ自動生成、それもなければ最初のトラック
    let selectedTrack = tracks.find(t => t.language === 'ja' && !t.isAutoGenerated) ||
                        tracks.find(t => t.language === 'ja') ||
                        tracks[0];
    
    console.log('Selected track:', selectedTrack);
    
    // 字幕データを取得
    const captionData = await fetchCaptionData(selectedTrack.baseUrl);
    const captions = parseCaptionJSON(captionData);
    
    console.log(`Loaded ${captions.length} captions`);
    return captions;
  } catch (error) {
    console.error('Error in getSmartCaptions:', error);
    return [];
  }
}

// インターフェース定義
export interface Caption {
  text: string;
  start: number;
  duration: number;
}

// DOM監視による字幕取得（フォールバック用・改善版）
export function observeCaptionsFromDOM(callback: (captions: Caption[]) => void): () => void {
  console.log('Starting DOM-based caption observation');
  
  // 字幕を有効にする（複数回試行）
  let enableAttempts = 0;
  const enableCaptionsWithRetry = () => {
    enableCaptions();
    enableAttempts++;
    
    // 3秒後に再度有効化を試みる（最大3回）
    if (enableAttempts < 3) {
      setTimeout(() => {
        const captionBtn = document.querySelector('.ytp-subtitles-button[aria-pressed="false"]');
        if (captionBtn) {
          console.log(`Retrying caption enable (attempt ${enableAttempts + 1})`);
          enableCaptionsWithRetry();
        }
      }, 3000);
    }
  };
  
  enableCaptionsWithRetry();
  
  // 字幕管理用の状態
  const captionMap = new Map<string, Caption>(); // キー: 開始時刻、値: 字幕
  const completedTexts = new Map<string, number>(); // 完了済みテキストと完了時刻
  let observationCount = 0; // 観測回数
  
  // デバッグ用: 処理状況を追跡
  const debugState = {
    lastProcessedTexts: new Set<string>(),
    duplicateCount: 0,
    totalObservations: 0
  };
  
  const captionObserver = new MutationObserver(() => {
    debugState.totalObservations++;
    observationCount++;
    
    const captionElements = document.querySelectorAll('.ytp-caption-segment');
    if (captionElements.length === 0) return;
    
    const videoElement = document.querySelector('video');
    if (!videoElement) return;
    
    const currentTime = videoElement.currentTime;
    
    // 現在表示されているテキストを収集（重複排除）
    const currentTexts = new Set<string>();
    const textsByTime = new Map<string, string[]>(); // 時刻ごとにテキストをグループ化
    
    captionElements.forEach((element) => {
      let text = element.textContent || '';
      
      // デバッグ: 元のテキストを記録
      const originalText = text;
      
      // YouTube UIの要素を除去
      const uiPatterns = [
        /英語\(自動生成\)>>/g,  // 「英語(自動生成)>>」を除去
        /英語\(自動生成\)>>日本語をクリックして設定/g,
        />>.*をクリックして設定/g,
        /をクリックして設定/g,
        /\[.*\]/g,
        /\(.*\)$/g,
        /英語$/g,
        /日本語$/g,
        /^>>/g  // 先頭の >> を削除
      ];
      
      for (const pattern of uiPatterns) {
        const before = text;
        text = text.replace(pattern, '').trim();
        if (before !== text) {
          console.log(`🧙 Pattern ${pattern} removed: "${before}" → "${text}"`);
        }
      }
      
      // 特別なケース: 「英語(自動生成)>>」のみの場合は完全に無視
      if (originalText === '英語(自動生成)>>' || originalText === '英語（自動生成）>>' || 
          originalText.match(/^英語[(（]自動生成[)）]>>$/)) {
        return; // この要素をスキップ
      }
      
      if (text && text.length > 1) {
        currentTexts.add(text);
        
        // 時刻ごとにグループ化（0.5秒の精度）
        const timeKey = (Math.round(currentTime * 2) / 2).toFixed(1);
        if (!textsByTime.has(timeKey)) {
          textsByTime.set(timeKey, []);
        }
        const timeTexts = textsByTime.get(timeKey)!;
        if (!timeTexts.includes(text)) {
          timeTexts.push(text);
        }
      }
    });
    
    // 各時刻グループから最も長いテキストのみを採用
    const uniqueTexts: string[] = [];
    const timeKeysArray = Array.from(textsByTime.keys()).sort();
    
    for (const timeKey of timeKeysArray) {
      const texts = textsByTime.get(timeKey)!;
      if (texts.length > 1) {
        // 同じ時刻に複数のテキストがある場合
        // 1. 部分テキストを除外
        const filteredTexts = texts.filter(text => {
          // 他のテキストに完全に含まれている場合は除外
          return !texts.some(other => other !== text && other.includes(text));
        });
        
        // 2. 最も長いものを選択
        const selectedText = filteredTexts.length > 0 
          ? filteredTexts.reduce((a, b) => a.length > b.length ? a : b)
          : texts[0];
          
        uniqueTexts.push(selectedText);
        if (texts.length > 1) {
          console.log(`⏱️ Time ${timeKey}: ${texts.length} texts → selected: "${selectedText.substring(0, 30)}..."`);
        }
      } else {
        uniqueTexts.push(texts[0]);
      }
    }
    
    // デバッグ: 同じテキストが複数回出現している場合
    if (captionElements.length > uniqueTexts.length) {
      console.log(`⚠️ Duplicate elements detected: ${captionElements.length} elements → ${uniqueTexts.length} unique texts`);
      debugState.duplicateCount++;
    }
    
    // 各テキストを処理
    uniqueTexts.forEach((text) => {
      // 既に完了済みのテキストかチェック（最近のものは除外）
      const completedTime = completedTexts.get(text);
      if (completedTime !== undefined && currentTime - completedTime < 5) {
        // 5秒以内に同じテキストは無視
        return;
      }
      
      // 部分的なテキストが既に存在する場合はスキップ
      for (const [_, caption] of captionMap.entries()) {
        // このテキストが既存の字幕に含まれている（部分的）
        if (caption.text.includes(text) && caption.text !== text && 
            Math.abs(caption.start - currentTime) < 2) {
          console.log(`⏭️ Skipping partial text: "${text}" (already in "${caption.text.substring(0, 30)}...")`);
          return;
        }
      }
      
      // 字幕として記録
      const captionKey = `${currentTime.toFixed(1)}-${text.substring(0, 20)}`;
      
      // 既存の字幕を探す（時間が近いもの）
      let existingCaption: Caption | null = null;
      let existingKey: string | null = null;
      
      for (const [key, caption] of captionMap.entries()) {
        // 同じテキストで、時間が近い（前後5秒以内）
        if (caption.text === text && Math.abs(caption.start - currentTime) < 5) {
          existingCaption = caption;
          existingKey = key;
          break;
        }
        
        // テキストが前のバージョンを含む（増分更新）
        if (text.startsWith(caption.text) && text.length > caption.text.length &&
            Math.abs(caption.start - currentTime) < 3) {
          existingCaption = caption;
          existingKey = key;
          break;
        }
      }
      
      if (existingCaption && existingKey) {
        // 既存の字幕を更新
        existingCaption.text = text;
        existingCaption.duration = Math.max(existingCaption.duration, currentTime - existingCaption.start + 1);
      } else {
        // 新しい字幕として追加
        captionMap.set(captionKey, {
          text: text,
          start: currentTime,
          duration: 2 // デフォルト2秒
        });
        console.log(`📝 New caption at ${currentTime.toFixed(1)}s: "${text.substring(0, 40)}..."`);
      }
    });
    
    // 画面から消えたテキストを完了済みとしてマーク
    for (const [_key, caption] of captionMap.entries()) {
      // 現在表示されていないテキスト
      if (!currentTexts.has(caption.text)) {
        // まだ完了済みでない場合
        if (!completedTexts.has(caption.text)) {
          completedTexts.set(caption.text, caption.start + caption.duration);
          console.log(`✅ Caption completed: "${caption.text.substring(0, 40)}..."`);
        }
      }
    }
    
    // 古い完了済みテキストを削除（メモリ節約）
    for (const [text, time] of completedTexts.entries()) {
      if (currentTime - time > 30) { // 30秒以上前のものは削除
        completedTexts.delete(text);
      }
    }
    
    // 古い字幕を削除（5分以上前のものだけ削除）
    for (const [key, caption] of captionMap.entries()) {
      if (caption.start + caption.duration < currentTime - 300) {
        captionMap.delete(key);
      }
    }
    
    // デバッグ情報を定期的に出力
    if (observationCount % 50 === 0) {
      console.log(`📊 Caption stats: ${captionMap.size} captions, ${completedTexts.size} completed, ${debugState.duplicateCount} duplicate detections`);
    }
    
    // コールバック
    const allCaptions = Array.from(captionMap.values())
      .sort((a, b) => a.start - b.start);
    callback(allCaptions);
  });
  
  // 字幕コンテナを監視
  const setupObserver = () => {
    const captionContainer = document.querySelector('.ytp-caption-window-container');
    if (captionContainer) {
      captionObserver.observe(captionContainer, {
        childList: true,
        subtree: true,
        characterData: true
      });
      console.log('Started observing caption container');
      return true;
    }
    return false;
  };
  
  if (!setupObserver()) {
    console.log('Caption container not found, will retry...');
    // リトライ
    const retryInterval = setInterval(() => {
      if (setupObserver()) {
        clearInterval(retryInterval);
      }
    }, 1000);
    
    // 10秒後にリトライを停止
    setTimeout(() => clearInterval(retryInterval), 10000);
  }
  
  // クリーンアップ関数を返す
  return () => {
    captionObserver.disconnect();
    console.log('Stopped observing captions');
    console.log(`Final stats: ${debugState.totalObservations} observations, ${debugState.duplicateCount} duplicate detections`);
  };
}

// YouTube字幕を有効にする
function enableCaptions() {
  try {
    // 方法1: 字幕ボタンをクリック
    const subtitleButton = document.querySelector('.ytp-subtitles-button') as HTMLButtonElement;
    if (subtitleButton) {
      // aria-pressed属性をチェックして字幕がオフの場合はクリック
      if (subtitleButton.getAttribute('aria-pressed') === 'false') {
        console.log('Clicking subtitle button to enable captions');
        subtitleButton.click();
        
        // クリック後に状態を確認
        setTimeout(() => {
          const pressed = subtitleButton.getAttribute('aria-pressed');
          console.log('Subtitle button state after click:', pressed);
        }, 500);
      } else {
        console.log('Captions already enabled');
      }
    } else {
      console.log('Subtitle button not found');
    }
    
    // 方法2: YouTube Player APIを使う
    const player = document.querySelector('#movie_player') as any;
    if (player && player.getOption) {
      try {
        // 利用可能な字幕トラックを取得
        const tracks = player.getOption('captions', 'tracklist');
        if (tracks && tracks.length > 0) {
          console.log('Available caption tracks:', tracks.length);
          // 日本語字幕を優先、なければ最初のトラック
          const jpTrack = tracks.find((t: any) => t.languageCode === 'ja') || tracks[0];
          player.setOption('captions', 'track', jpTrack);
          console.log('Enabled captions via Player API');
        }
      } catch (e) {
        console.log('Player API method failed:', e);
      }
    }
  } catch (error) {
    console.error('Error enabling captions:', error);
  }
}